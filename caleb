#! /usr/bin/env python

import requests
import sys
import logging


def parse_string(s):
    """Return the payload from user-input string

    Args:
        s (str): user-input string

    Returns:
        dict: A dictionary of author, title, year that will be used for the GET
        request.
    """
    # underscore -> space
    s = s.replace('_', ' ')

    # Separate entries by colon
    pieces = s.split(':')
    payload = dict(zip(['au', 'ti', 'year'], pieces))
    payload['format'] = 'bibtex'
    return payload


def get_bibtex(s):
    """Return the first bibtex entry given the user-input string

    Args:
        s (str): user-input string

    Returns:
        (int, str): A tuple where the first entry is the number of results and
        the single entry is the first bibtex entry. If no bibtex found, the
        second entry will be an empty string. 
    """
    payload = parse_string(s)
    r = requests.get('https://mathscinet.ams.org/mrlookup', params=payload)
    output = r.text

    num_results = output.count('<pre>')

    return num_results, output.split('<pre>')[1].split('</pre>')[0].strip('\n')


def parse_bib(filename):
    """Return a list of bib entries that are already in the bib file.

    Args:
        filename (str): filename of bib file

    Returns:
        set: Set of bibtex entries already specified
    """
    all_entries = set()
    try:
        with open(filename, 'r') as f:
            for line in f:
                if line.startswith("@"):
                    all_entries.add(line.split('{', 1)[1].split(',', 1)[0])
    except FileNotFoundError:
        pass
    return all_entries


def parse_aux(filename):
    """Return a list of bib entries that are referenced in the tex file.

    Args:
        filename (str): filename of bib file

    Returns:
        set: Set of bibtex entries referenced in the tex file.
    """
    with open(filename, "r") as f:
        citations = set()
        for line in f:
            if line.startswith("\\citation{"):
                citation = line[10:-2]
                if citation.count(':'):
                    citations.add(citation)
    return citations


def append_missing(missing_cits, bib_file):
    """Append the missing bibtex entries to the bibfile.

    Args:
        missing_cits (set): set of citations to be appended
        bib_file (str): filename to bib file.
    """
    with open(bib_file, "a") as f:
        for citation in missing_cits:
            logging.info("Working on {}".format(citation))

            num, new_entry = get_bibtex(citation)
            logging.info("Found {} results".format(num))

            # No results
            if not num:
                print('No results found for: {}'.format(citation))
                return
            # Multiple results
            elif num > 1:
                print('Multiple results found for: {}'.format(citation))

            logging.info("Inputing {}".format(new_entry))

            # Here we assume the first line is always
            # @something {OLD_CITATION,\n
            # Replace OLD_CITATION with citation
            # Use { and ,\n to find and replace
            a, b = new_entry.split('{', 1)
            new_citation = a + '{' + citation + ',\n' + b.split(',\n', 1)[1]

            # write to bib file
            f.write('\n')
            f.write(new_citation)
            f.write('\n')


def main():
    name = sys.argv[1]
    logging.basicConfig(level=logging.INFO)

    aux_file = name + ".aux"
    logging.info(".aux file: {}".format(aux_file))

    bib_file = name + ".bib"
    logging.info(".bib file: {}".format(bib_file))

    citations = parse_aux(aux_file)
    existing_bibs = parse_bib(bib_file)

    missing_cits = citations.difference(existing_bibs)
    logging.info("Number of missing citations: {}".format(len(missing_cits)))
    logging.info("Missing citations: {}".format(missing_cits))

    if missing_cits:
        append_missing(missing_cits, bib_file)


if __name__ == "__main__":
    main()
